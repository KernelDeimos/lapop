#!/usr/local/bin/node
'use strict';
const fs = require('fs');
const path = require('path');

var memory = require(
  './bootstrapping/interpreting/memory');
var registry = require(
  './bootstrapping/interpreting/registry');
memory.id = 2;
var interpreter = require(
  './bootstrapping/interpreting/interpreter')({
    registry: memory.registry });
var streams = require(
  './bootstrapping/interpreting/streams');
var evaluators = require(
  './bootstrapping/interpreting/evaluators');
var definitions = require(
  './bootstrapping/parsing/definitions')({
    registry: memory.registry });
var primitives = require(
  './bootstrapping/parsing/primitives');
var dres   = require(
  './bootstrapping/utilities/descriptiveresults');
var dhelp  = require(
  './bootstrapping/utilities/datahelper');
var fmaps  = require(
  './bootstrapping/interpreting/functionmaps');
var context  = require(
  './bootstrapping/language/context');

if ( process.env.hasOwnProperty('LEPOT_VERBOSE') && process.env.LEPOT_VERBOSE == 1 ) {
  memory.addListener(o => console.log(o));
}

var codePattern = [['list',['list', ['symbol', 'list']]]];
memory.registry('pattern', 'script').def = codePattern;
memory.registry('pattern', 'now').def = codePattern;
memory.registry('pattern', 'put').def = [['list',
  ['list', ['symbol', 'symbol-for-pattern'], ['symbol', 'sym_']],
  ['list', ['symbol', 'symbol']],
  ['list', ['symbol', 'pattern-from-symbol'], ['symbol', 'sym_']],
]];

var lib = {};

var root = context.newStandardExecutionContext();
lib.exec = null;

lib.execStream = (s) => {
    // Script is allowed to begin with whitespace
    s = primitives.eat_whitespace(s).stream;

    let tokens = primitives.parse_list_tokens(null, primitives.try_any, s);
    let exS = streams.newListStream(tokens.value, 0);
    // console.log(JSON.stringify(lis, false, 4));
    root.execBlockHere(exS);
    return dres.resOK();
}


lib.load = filename => {
  var data = fs.readFileSync(filename);
  var res = lib.execStream(primitives.newStream(
    data.toString(), 0));
}

lib.badREPL = (start, end) => {
  var replPre = "\x1B[36;1m|REPL|\x1B[0m ";
  var readline = require('readline');
  var rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    prompt: ''
  });

  var start = `def script main [\n`;
  var end = `]\n`;
  var codeMode = false;
  var rewrite = buf => codeMode ? start+buf+end : buf;

  var buffer = "";

  lib.execStream(primitives.newStream(`
    :fn logrepl {msg [string]} [ (logger.notice (msg)) ]
    put pattern logrepl [ [any] ]
    logrepl ''
    logrepl 'You are in REPL mode!'
    logrepl 'Enter on an empty line to call the executor.'
    logrepl 'Press Ctrl+D (EOF) to exit.'
    logrepl 'The !HELP command will show REPL commands.'
  `, 0));

  rl.on('line', function(line){
    if ( line === "" ) {
      let res = lib.execStream(primitives.newStream(
        rewrite(buffer), 0));
      if ( dres.isNegative(res) ) {
        console.log(replPre + "Error: ", res);
      }
      console.log('> ' + res);
      buffer = "";
    }
    else if ( line === '!CODE' ) {
      codeMode = !codeMode;
      console.log(replPre+'SCRIPT MODE '+(codeMode ? 'ON' : 'OFF'));
    }
    else if ( line === '!EXIT') {
      console.log(replPre+'QUITTING');
      rl.close();
    }
    else if ( line.startsWith('!COPY') ) {
      let parts = line.split(' ');
      let data = fs.readFileSync(parts[1]);
      buffer += data.toString();
    }
    else if ( line === '!SHOW' ) {
      console.log(rewrite(buffer));
    }
    else if ( line === '!CLEAR' ) {
      buffer = "";
    }
    else if ( line === '!WHY' ) {
      console.log(
        '\x1B[33;1mW   \x1B[36;1mY     \x1B[32;1m' +
        '\x1B[31;1mN   \x1B[35mT\n  \x1B[34mH    ' +
        '     \x1B[33;1mO\x1B[0m' +
        '\n' +
        '      Î» Y'
        );
    }
    else if ( line === '!HELP' ) {
      let t = '      ';
      console.log(replPre+' === REPL COMMANDS ===\n' +
      t+`!CODE  - toggle "script mode". If script mode is ON then\n` +
      t+`         code is wrapped in "def script main [...]"\n` +
      t+`!EXIT  - Alternative command to exit REPL.\n` +
      t+`!COPY <filename>\n` +
      t+`       - copies a file's contents into the REPL buffer\n` +
      t+`         as though you typed it yourself.\n` +
      t+`!SHOW  - Show buffer contents\n` +
      t+`!CLEAR - Clear buffer contents\n` +
      t+`!WHY   - This is another REPL command that exists` );
    }
    else {
      buffer += line + "\n";
    }
  })
};

// Process builtin definitions
var directoryloader = require('./bootstrapping/language/tool/directoryloader');

directoryloader.exectx = root;

directoryloader.loadDirectory(
  path.join(__dirname, 'definitions')
).then(() => {
  // Add loaded functions to the interpreter context
  var loadedFunctions = registry.select(memory.registry_,
    { 'pattern': 'function' });
  loadedFunctions.forEach(def => {
    let newFn = root.getOwner(':fn').call;
    let args = [
      { type: 'symbol', value: def.for },
      ...def.value.map(
        v => dhelp.processData(null, v))
    ];
    let res = newFn(args, root);
    if ( dres.isNegative(res) ) {
      throw new Error(JSON.stringify(res));
    }
  });

  var args = process.argv.slice(2);

  if ( args.length > 0 && args[0] !== '--' ) {
    let scriptOrFile = args[0].trimLeft();
    let subCommandPkg = 'lepot.tools.lepot.subcommands.';
    let subCommands = registry.select(memory.registry_, {
      pattern: 'script',
      under: {
        startsWith: subCommandPkg,
        recursive: true
      }
    });
    for ( let i=0; i < subCommands.length; i++) {
      if ( subCommands[i].for ===
        subCommandPkg + args[0].trimRight()
      ) {
        let scriptBody = subCommands[i].value[0];
        scriptBody = dhelp.processData(null, scriptBody);
        let exS = streams.newListStream(scriptBody.value, 0);
        memory.env.args = args.slice(1);
        root.execBlockHere(exS);
        return;
      }
    }

    lib.load(args[0]);
  } else {
    if ( args.length > 1 ) memory.env.args = args.slice(1);
    lib.badREPL();
  }
}).catch(e => { throw e });
