#!/usr/local/bin/node
'use strict';
const fs = require('fs');

var memory = require(
  './bootstrapping/interpreting/memory');
var interpreter = require(
  './bootstrapping/interpreting/interpreter')({
    registry: memory.registry });
var streams = require(
  './bootstrapping/interpreting/streams');
var evaluators = require(
  './bootstrapping/interpreting/evaluators');
var definitions = require(
  './bootstrapping/parsing/definitions')({
    registry: memory.registry });
var primitives = require(
  './bootstrapping/parsing/primitives');
var dres   = require(
  './bootstrapping/utilities/descriptiveresults');
var dhelp  = require(
  './bootstrapping/utilities/datahelper');
var fmaps  = require(
  './bootstrapping/interpreting/functionmaps');
var context  = require(
  './bootstrapping/language/context');

if ( process.env.hasOwnProperty('LEPOT_VERBOSE') ) {
  memory.addListener(o => console.log(o));
}

var codePattern = [['list',['list', ['symbol', 'list']]]];
memory.registry('pattern', 'script').def = codePattern;
memory.registry('pattern', 'now').def = codePattern;

var lib = {};

var root = context.newStandardExecutionContext();
lib.exec = null;

lib.execStream = (s) => {
    // Script is allowed to begin with whitespace
    s = primitives.eat_whitespace(s).stream;

    while ( ! s.eof() ) {
        let result = definitions.try_def(s);
        s = result.stream;
        if ( dres.isNegative(result) ) {
            return result;
        }
        memory.registry(result.of, result.for).def = result.value;
        if ( result.of === 'script' && result.for === 'main' ) {
          let lis = dhelp.processData(null, result.value[0]);
          root.execBlockHere(lis);
        }
        s = primitives.eat_whitespace(s).stream;
    }

    return dres.resOK();
}


lib.load = filename => {
  var data = fs.readFileSync(filename);
  var res = lib.execStream(primitives.newStream(
    data.toString(), 0));
}

lib.badREPL = (start, end) => {
  var replPre = "\x1B[36;1m|REPL|\x1B[0m ";
  var readline = require('readline');
  var rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    prompt: ''
  });

  var start = `def script main [\n`;
  var end = `]\n`;
  var codeMode = false;
  var rewrite = buf => codeMode ? start+buf+end : buf;

  var buffer = "";

  lib.execStream(primitives.newStream(`
    def script main [
      (logger.notice '')
      (logger.notice 'You are in REPL mode!')
      (logger.notice 'Enter on an empty line to call the executor.')
      (logger.notice 'Press Ctrl+D (EOF) to exit.')
      (logger.notice 'The !HELP command will show REPL commands.')
    ]
  `, 0));

  rl.on('line', function(line){
    if ( line === "" ) {
      let res = lib.execStream(primitives.newStream(
        rewrite(buffer), 0));
      if ( dres.isNegative(res) ) {
        console.log(replPre + "Error: ", res);
      }
      console.log('> ' + res);
      buffer = "";
    }
    else if ( line === '!CODE' ) {
      codeMode = !codeMode;
      console.log(replPre+'SCRIPT MODE '+(codeMode ? 'ON' : 'OFF'));
    }
    else if ( line === '!EXIT') {
      console.log(replPre+'QUITTING');
      rl.close();
    }
    else if ( line.startsWith('!COPY') ) {
      let parts = line.split(' ');
      let data = fs.readFileSync(parts[1]);
      buffer += data.toString();
    }
    else if ( line === '!SHOW' ) {
      console.log(rewrite(buffer));
    }
    else if ( line === '!CLEAR' ) {
      buffer = "";
    }
    else if ( line === '!WHY' ) {
      console.log(
        '\x1B[33;1mW   \x1B[36;1mY     \x1B[32;1m' +
        '\x1B[31;1mN   \x1B[35mT\n  \x1B[34mH    ' +
        '     \x1B[33;1mO\x1B[0m' +
        '\n' +
        '      Î» Y'
        );
    }
    else if ( line === '!HELP' ) {
      let t = '      ';
      console.log(replPre+' === REPL COMMANDS ===\n' +
      t+`!CODE  - toggle "script mode". If script mode is ON then\n` +
      t+`         code is wrapped in "def script main [...]"\n` +
      t+`!EXIT  - Alternative command to exit REPL.\n` +
      t+`!COPY <filename>\n` +
      t+`       - copies a file's contents into the REPL buffer\n` +
      t+`         as though you typed it yourself.\n` +
      t+`!SHOW  - Show buffer contents\n` +
      t+`!CLEAR - Clear buffer contents\n` +
      t+`!WHY   - This is another REPL command that exists` );
    }
    else {
      buffer += line;
    }
  })
};

var args = process.argv.slice(2);

if ( args.length > 0 ) {
  lib.load(args[0]);
} else {
  lib.badREPL();
}
